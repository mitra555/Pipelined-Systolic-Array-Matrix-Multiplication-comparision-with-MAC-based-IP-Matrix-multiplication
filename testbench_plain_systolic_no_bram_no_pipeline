`timescale 1ns/1ps

module tb_3x3;

    parameter DATA_WIDTH = 8;

    logic clk, rst, clear;
    logic signed [DATA_WIDTH-1:0] A_in [2:0];
    logic signed [DATA_WIDTH-1:0] B_in [2:0];
    logic signed [2*DATA_WIDTH-1:0] C_out [2:0][2:0];
    logic done;

    top_3x3 #(DATA_WIDTH) uut (
        .clk(clk),
        .rst(rst),
        .clear(clear),
        .A_in(A_in),
        .B_in(B_in),
        .C_out(C_out),
        .done(done)
    );

    // Clock: 10 ns period
    always #5 clk = ~clk;

    // Local matrices (for testbench use)
    logic signed [DATA_WIDTH-1:0] Amat [2:0][2:0];
    logic signed [DATA_WIDTH-1:0] Bmat [2:0][2:0];

    initial begin
        // initialize clock and control signals
        clk = 0;
        rst = 0;
        clear = 0;

        // Initialize matrices
        // A = Identity
        Amat[0][0] = 1; Amat[0][1] = 0; Amat[0][2] = 0;
        Amat[1][0] = 0; Amat[1][1] = 1; Amat[1][2] = 0;
        Amat[2][0] = 0; Amat[2][1] = 0; Amat[2][2] = 1;

        // B = 0..8 row-major:
        // [ 0 1 2 ]
        // [ 3 4 5 ]
        // [ 6 7 8 ]
        Bmat[0][0] = 0; Bmat[0][1] = 1; Bmat[0][2] = 2;
        Bmat[1][0] = 3; Bmat[1][1] = 4; Bmat[1][2] = 5;
        Bmat[2][0] = 6; Bmat[2][1] = 7; Bmat[2][2] = 8;

        // Reset pulse
        #20;
        rst = 1;    // release reset
        #10;

        // Clear accumulators first
        clear = 1;
        @(posedge clk);
        clear = 0;

        // STREAM: for k = 0..2, feed A_in = column k of A, B_in = row k of B
        // (This is standard systolic streaming: A_in[i] = A[i][k], B_in[j] = B[k][j])
        for (int k = 0; k < 3; k = k + 1) begin
            // Drive inputs combinationally (will be sampled by PEs each clock)
            for (int i = 0; i < 3; i = i + 1)
                A_in[i] = Amat[i][k];

            for (int j = 0; j < 3; j = j + 1)
                B_in[j] = Bmat[k][j];

            // hold for one clock so PEs capture these values
            @(posedge clk);
        end

        // After streaming all k, keep inputs zero (optional)
        for (int i = 0; i < 3; i = i + 1) begin
            A_in[i] = 0;
            B_in[i] = 0;
        end

        // Wait extra cycles to let accumulators finish (conservative)
        repeat (10) @(posedge clk);

        // Display the computed matrix
        $display("\n==== OUTPUT MATRIX (C = A Ã— B) ====");
        for (int r = 0; r < 3; r = r + 1) begin
            $write("Row %0d : ", r);
            for (int c = 0; c < 3; c = c + 1) begin
                // Print signed decimal value
                $write("%0d ", $signed(C_out[r][c]));
            end
            $write("\n");
        end

        $finish;
    end

endmodule
