module top_module #(parameter SIZE = 4, parameter DATA_WIDTH = 8)(
    (* DONT_TOUCH = "TRUE" *)input  logic clk,
   (* DONT_TOUCH = "TRUE" *) input  logic rst,
  (* DONT_TOUCH = "TRUE" *)  input  logic clear,

    // Input matrices (1 value per row/column per cycle)
   (* DONT_TOUCH = "TRUE" *) input  logic signed [DATA_WIDTH-1:0] A_in [SIZE-1:0],
 (* DONT_TOUCH = "TRUE" *)   input  logic signed [DATA_WIDTH-1:0] B_in [SIZE-1:0],

  (* DONT_TOUCH = "TRUE" *)  output logic signed [2*DATA_WIDTH-1:0] C_out [SIZE-1:0][SIZE-1:0],
  (* DONT_TOUCH = "TRUE" *)  output logic done
);
(* DONT_TOUCH = "TRUE" *)
    // Instantiate the systolic array
    SystolicArray #(
        .SIZE(SIZE),
        .DATA_WIDTH(DATA_WIDTH)
    ) systolic_array_inst (
        .clk(clk),
        .rst(rst),
        .clear(clear),
        .A_in(A_in),
        .B_in(B_in),
        .done(done),
        .C_out(C_out)
    );

endmodule
module SystolicArray #(parameter SIZE = 3, parameter DATA_WIDTH = 8)(
   (* DONT_TOUCH = "TRUE" *) input  logic clk,
 (* DONT_TOUCH = "TRUE" *)   input  logic rst,   // active-low reset: rst==0 -> in reset, rst==1 -> running
(* DONT_TOUCH = "TRUE" *)    input  logic clear,
(* DONT_TOUCH = "TRUE" *)    input  logic signed [DATA_WIDTH-1:0] A_in [SIZE-1:0],
  (* DONT_TOUCH = "TRUE" *)  input  logic signed [DATA_WIDTH-1:0] B_in [SIZE-1:0],
  (* DONT_TOUCH = "TRUE" *)  output logic signed [2*DATA_WIDTH-1:0] C_out [SIZE-1:0][SIZE-1:0],
   (* DONT_TOUCH = "TRUE" *) output logic done
);

    // Internal data wires (dimensions chosen so indices used below are valid)
(* KEEP = "TRUE" *)logic signed [DATA_WIDTH-1:0] a_wire [0:SIZE][0:SIZE-1]; // a_wire[row][col]
(* KEEP = "TRUE" *)logic signed [DATA_WIDTH-1:0] b_wire [0:SIZE-1][0:SIZE]; // b_wire[row][col]
 (* KEEP = "TRUE" *)logic signed [2*DATA_WIDTH-1:0] c_partial [0:SIZE-1][0:SIZE-1];
    // Initialize internal wires to avoid 'X' propagation
initial begin
    for (int i = 0; i <= SIZE; i++) begin
        for (int j = 0; j < SIZE; j++) begin
            a_wire[i][j] = '0;
        end
    end
    for (int i = 0; i < SIZE; i++) begin
        for (int j = 0; j <= SIZE; j++) begin
            b_wire[i][j] = '0;
        end
    end
end

    // Feed inputs into the left/top edges (combinational)
    // Only drive the edge entries here; other a_wire / b_wire entries are driven by PE outputs.
    generate
        genvar idx;
        for (idx = 0; idx < SIZE; idx++) begin : FEED
            // left edge for each row
            assign a_wire[idx][0] = A_in[idx];
            // top edge for each column
            assign b_wire[0][idx] = B_in[idx];
        end
    endgenerate

    // Instantiate Processing Elements (PEs)
    genvar i, j;
    generate
        for (i = 0; i < SIZE; i++) begin : ROW
            for (j = 0; j < SIZE; j++) begin : COL
                // Connections:
                // - a input is a_wire[i][j]
                // - b input is b_wire[i][j]
                // - a_out drives a_wire[i][j+1] (right)
                // - b_out drives b_wire[i+1][j] (down)
                (* DONT_TOUCH = "TRUE" *)
                // Note: a_wire rows have indices 0..SIZE and cols 0..SIZE-1 so j+1 up to SIZE valid.
                PE #(.DATA_WIDTH(DATA_WIDTH)) pe_inst (
                    .a       (a_wire[i][j]),
                    .b       (b_wire[i][j]),
                    .clk     (clk),
                    .rst     (rst),
                    .clear   (clear),
                    .a_out   (a_wire[i][j+1]),
                    .b_out   (b_wire[i+1][j]),
                    .C_out   (c_partial[i][j])
                );
            end
        end
    endgenerate

    // Expose outputs
    always_comb begin
        for (int r = 0; r < SIZE; r++)
            for (int c = 0; c < SIZE; c++)
                C_out[r][c] = c_partial[r][c];
    end

    // Simple done: allow enough cycles after reset for pipeline to settle
    // Use active-low reset sensitivity to match PE.
    logic [15:0] cycle_count;
    always_ff @(posedge clk or negedge rst) begin
        if (!rst) begin
            cycle_count <= 0;
        end else begin
            if (cycle_count < SIZE*6) // conservative flush budget
                cycle_count <= cycle_count + 1;
        end
        end
assign done = (cycle_count >= 2*SIZE*SIZE);
endmodule
module PE #(parameter DATA_WIDTH = 10)(
    input  logic signed [DATA_WIDTH-1:0] a,
    input  logic signed [DATA_WIDTH-1:0] b,
    input  logic clk,
    input  logic rst,    // active-low reset
    input  logic clear,
    output logic signed [DATA_WIDTH-1:0] a_out,
    output logic signed [DATA_WIDTH-1:0] b_out,
    output logic signed [2*DATA_WIDTH-1:0] C_out
);
    localparam ACCW = 2*DATA_WIDTH;

    logic signed [2*DATA_WIDTH-1:0] mult;
    logic signed [ACCW-1:0] acc;

    assign mult = a * b;

    always_ff @(posedge clk or negedge rst) begin
        if (!rst) begin
            acc   <= '0;
            a_out <= '0;
            b_out <= '0;
        end else begin
            if (clear)
                acc <= '0;
            else
                acc <= acc + mult;

            // propagate a and b to neighbors (registered)
            a_out <= a;
            b_out <= b;
        end
    end

    assign C_out = acc;

endmodule
