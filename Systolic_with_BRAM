module SystolicArray #(parameter SIZE = 3, parameter DATA_WIDTH = 8)(
   (* DONT_TOUCH = "TRUE" *) input  logic clk,
 (* DONT_TOUCH = "TRUE" *)   input  logic rst,   // active-low reset: rst==0 -> in reset, rst==1 -> running
(* DONT_TOUCH = "TRUE" *)    input  logic clear,
(* DONT_TOUCH = "TRUE" *)    input  logic signed [DATA_WIDTH-1:0] A_in [SIZE-1:0],
  (* DONT_TOUCH = "TRUE" *)  input  logic signed [DATA_WIDTH-1:0] B_in [SIZE-1:0],
  (* DONT_TOUCH = "TRUE" *)  output logic signed [2*DATA_WIDTH-1:0] C_out [SIZE-1:0][SIZE-1:0],

     output logic done
);

    // Internal data wires (dimensions chosen so indices used below are valid)
(* KEEP = "TRUE" *)logic signed [DATA_WIDTH-1:0] a_wire [0:SIZE][0:SIZE-1]; // a_wire[row][col]
(* KEEP = "TRUE" *)logic signed [DATA_WIDTH-1:0] b_wire [0:SIZE-1][0:SIZE]; // b_wire[row][col]
 (* KEEP = "TRUE" *)logic signed [2*DATA_WIDTH-1:0] c_partial [0:SIZE-1][0:SIZE-1];
    // Initialize internal wires to avoid 'X' propagation
initial begin
    for (int i = 0; i <= SIZE; i++) begin
        for (int j = 0; j < SIZE; j++) begin
            a_wire[i][j] = '0;
        end
    end
    for (int i = 0; i < SIZE; i++) begin
        for (int j = 0; j <= SIZE; j++) begin
            b_wire[i][j] = '0;
        end
    end
end

    // Feed inputs into the left/top edges (combinational)
    // Only drive the edge entries here; other a_wire / b_wire entries are driven by PE outputs.
    generate
        genvar idx;
        for (idx = 0; idx < SIZE; idx++) begin : FEED
            // left edge for each row
            assign a_wire[idx][0] = A_in[idx];
            // top edge for each column
            assign b_wire[0][idx] = B_in[idx];
        end
    endgenerate

    // Instantiate Processing Elements (PEs)
    genvar i, j;
    generate
        for (i = 0; i < SIZE; i++) begin : ROW
            for (j = 0; j < SIZE; j++) begin : COL
                // Connections:
                // - a input is a_wire[i][j]
                // - b input is b_wire[i][j]
                // - a_out drives a_wire[i][j+1] (right)
                // - b_out drives b_wire[i+1][j] (down)
                
    (* dont_touch = "true", keep = "true" *)
                // Note: a_wire rows have indices 0..SIZE and cols 0..SIZE-1 so j+1 up to SIZE valid.
                PE #(.DATA_WIDTH(DATA_WIDTH)) pe_inst (
                    .a       (a_wire[i][j]),
                    .b       (b_wire[i][j]),
                    .clk     (clk),
                    .rst     (rst),
                    .clear   (clear),
                    .a_out   (a_wire[i][j+1]),
                    .b_out   (b_wire[i+1][j]),
                    .C_out   (c_partial[i][j])
                );
            end
        end
    endgenerate

    // Expose outputs
    always_comb begin
        for (int r = 0; r < SIZE; r++)
            for (int c = 0; c < SIZE; c++)
                C_out[r][c] = c_partial[r][c];
    end

    // Simple done: allow enough cycles after reset for pipeline to settle
    // Use active-low reset sensitivity to match PE.
    logic [15:0] cycle_count;
    always_ff @(posedge clk or negedge rst) begin
        if (!rst) begin
            cycle_count <= 0;
        end else begin
            if (cycle_count < SIZE*6) // conservative flush budget
                cycle_count <= cycle_count + 1;
        end
        end
assign done = (cycle_count >= 2*SIZE*SIZE);
endmodule
module PE #(parameter DATA_WIDTH = 10)(
    input  logic signed [DATA_WIDTH-1:0] a,
    input  logic signed [DATA_WIDTH-1:0] b,
    input  logic clk,
    input  logic rst,    // active-low reset
    input  logic clear,
    output logic signed [DATA_WIDTH-1:0] a_out,
    output logic signed [DATA_WIDTH-1:0] b_out,
    output logic signed [2*DATA_WIDTH-1:0] C_out
);
    localparam ACCW = 2*DATA_WIDTH;

    logic signed [2*DATA_WIDTH-1:0] mult;
    logic signed [ACCW-1:0] acc;

    assign mult = a * b;

    always_ff @(posedge clk or negedge rst) begin
        if (!rst) begin
            acc   <= '0;
            a_out <= '0;
            b_out <= '0;
        end else begin
            if (clear)
                acc <= '0;
            else
                acc <= acc + mult;

            // propagate a and b to neighbors (registered)
            a_out <= a;
            b_out <= b;
        end
    end

    assign C_out = acc;

endmodule
// top_module.sv - Fixed data feeding order
`timescale 1ns/1ps

module top_module #(
    parameter int N      = 3,
    parameter int AW     = 8,
    parameter int ACCW   = 2*AW,
    parameter int ADDRW  = 4
)(
    input  logic clk,
    input  logic reset,
    output logic done,
    output logic [ACCW*N*N-1:0] C_flat
);

    localparam int NUM = N * N;

    logic enaA, enaB;
    logic [ADDRW-1:0] addrA, addrB;
    logic [AW-1:0] doutA, doutB;
    logic [ADDRW-1:0] addr_tag_A_r1, addr_tag_A_r2;
    logic [ADDRW-1:0] addr_tag_B_r1, addr_tag_B_r2;
    logic [AW-1:0] doutA_r1, doutB_r1;
    logic [AW*NUM-1:0] A_flat, B_flat;
    logic loadedA, loadedB;

    blk_mem_gen_0 BRAM_A (
        .clka(clk),
        .ena(enaA),
        .wea(1'b0),
        .addra(addrA),
        .dina({AW{1'b0}}),
        .douta(doutA)
    );

    blk_mem_gen_1 BRAM_B (
        .clka(clk),
        .ena(enaB),
        .wea(1'b0),
        .addra(addrB),
        .dina({AW{1'b0}}),
        .douta(doutB)
    );

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            doutA_r1 <= '0;
            doutB_r1 <= '0;
            addr_tag_A_r1 <= '0;
            addr_tag_A_r2 <= '0;
            addr_tag_B_r1 <= '0;
            addr_tag_B_r2 <= '0;
            addrA <= '0;
            addrB <= '0;
            enaA <= 1'b0;
            enaB <= 1'b0;
            A_flat <= '0;
            B_flat <= '0;
            loadedA <= 1'b0;
            loadedB <= 1'b0;
        end else begin
            doutA_r1 <= doutA;
            doutB_r1 <= doutB;
            addr_tag_A_r1 <= addrA;
            addr_tag_A_r2 <= addr_tag_A_r1;
            addr_tag_B_r1 <= addrB;
            addr_tag_B_r2 <= addr_tag_B_r1;

            if (addr_tag_A_r2 < NUM) begin
                A_flat[AW*addr_tag_A_r2 +: AW] <= doutA_r1;
                if (addr_tag_A_r2 == (NUM-1)) loadedA <= 1'b1;
            end

            if (addr_tag_B_r2 < NUM) begin
                B_flat[AW*addr_tag_B_r2 +: AW] <= doutB_r1;
                if (addr_tag_B_r2 == (NUM-1)) loadedB <= 1'b1;
            end

            if (!enaA && !loadedA) enaA <= 1'b1;
            if (!enaB && !loadedB) enaB <= 1'b1;

            if (enaA && addrA < (NUM-1))
                addrA <= addrA + 1;
            if (enaB && addrB < (NUM-1))
                addrB <= addrB + 1;
                        if (reset) begin
        end else begin
            if (loadedA) enaA <= 1'b0;
            if (loadedB) enaB <= 1'b0;
        end
        end
    end



    // Systolic control
    logic rst_systolic_n;
    logic loaded_both;
    logic start_d, start_pulse;
    logic clear_pulse;
    logic [7:0] stream_cnt;
    logic streaming;
    logic streaming_d;  // Delayed streaming flag

    assign loaded_both = loadedA & loadedB;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            start_d <= 1'b0;
            start_pulse <= 1'b0;
        end else begin
            start_pulse <= loaded_both & ~start_d;
            start_d <= loaded_both;
        end
    end

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            rst_systolic_n <= 1'b0;
        end else begin
            rst_systolic_n <= loaded_both ? 1'b1 : 1'b0;
        end
    end

    // Clear pulse happens BEFORE first data arrives
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            clear_pulse <= 1'b0;
        end else begin
            // Clear on start pulse, will be deasserted next cycle when streaming begins
            clear_pulse <= start_pulse;
        end
    end

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            stream_cnt <= 0;
            streaming  <= 1'b0;
            streaming_d <= 1'b0;
        end else begin
            streaming_d <= streaming;
            
            if (start_pulse) begin
                stream_cnt <= 0;
                streaming <= 1'b1;  // Start streaming next cycle after clear
            end else if (streaming) begin
                if (stream_cnt < (N-1))
                    stream_cnt <= stream_cnt + 1;
                else
                    streaming <= 1'b0;
            end
        end
    end

    // Unpack matrices - ROW MAJOR ORDER from BRAM
    logic signed [AW-1:0] A_mat [0:N-1][0:N-1];
    logic signed [AW-1:0] B_mat [0:N-1][0:N-1];

    generate
        genvar r, c;
        for (r = 0; r < N; r++) begin : UNPACK_A
            for (c = 0; c < N; c++) begin : UNPACK_B
                // Row-major: element [r][c] is at index r*N + c
                assign A_mat[r][c] = $signed(A_flat[AW*(r*N + c) +: AW]);
                assign B_mat[r][c] = $signed(B_flat[AW*(r*N + c) +: AW]);
            end
        end
    endgenerate

    // Build input vectors for systolic array
    // CRITICAL: Feed column-by-column for A, row-by-row for B
    logic signed [AW-1:0] A_in_vec [0:N-1];
    logic signed [AW-1:0] B_in_vec [0:N-1];

    always_comb begin
        if (streaming) begin
            // For A: feed column 'stream_cnt' from all rows
            // A_in[row] should get A_mat[row][stream_cnt]
            for (int ii=0; ii<N; ii++) begin
                A_in_vec[ii] = A_mat[ii][stream_cnt];
            end
            
            // For B: feed row 'stream_cnt' from all columns  
            // B_in[col] should get B_mat[stream_cnt][col]
            for (int jj=0; jj<N; jj++) begin
                B_in_vec[jj] = B_mat[stream_cnt][jj];
            end
        end else begin
            A_in_vec = '{default: '0};
            B_in_vec = '{default: '0};
        end
    end

    // Instantiate systolic array
    logic signed [2*AW-1:0] C_mat [0:N-1][0:N-1];
    logic systolic_done;

    (* dont_touch = "true", keep = "true" *)
    SystolicArray #(
        .SIZE(N),
        .DATA_WIDTH(AW)
    ) systolic_inst (
        .clk(clk),
        .rst(rst_systolic_n),
        .clear(clear_pulse),
        .A_in(A_in_vec),
        .B_in(B_in_vec),
        .C_out(C_mat),
        .done(systolic_done)
    );

    // Flatten output with explicit assignment
    generate
        for (r = 0; r < N; r++) begin : FLATTEN_R
            for (c = 0; c < N; c++) begin : FLATTEN_C
                // Row-major packing: element [r][c] goes to bit position (r*N+c)*ACCW
                assign C_flat[(r*N + c)*ACCW +: ACCW] = C_mat[r][c];
            end
        end
    endgenerate

    assign done = systolic_done;

endmodule
